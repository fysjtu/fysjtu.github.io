---
layout:     post   				    # 使用的布局（不需要改）
title:      Leetcode 				# 标题 
subtitle:   刷题记录07/16 #副标题
date:       2020-07-16 				# 时间
author:     fy 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 刷题
---
## 24.两两交换链表节点
递归
```
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if(head==nullptr || head->next==nullptr) {
            return head;
        }
        ListNode *p1 = head;
        ListNode *p2 = p1->next;
        p1->next = swapPairs(p2->next);
        p2->next = p1;
        return p2;
    }
};
```
迭代
```
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if(!head) return NULL;
        ListNode *cur, *dummy, *mark;
        cur=head;
        if(cur->next) mark=cur->next;
        else return cur;
        dummy=new ListNode(-1); dummy->next=cur;
        while(cur&&cur->next){
            dummy->next=cur->next;
            cur->next=dummy->next->next;
            dummy->next->next=cur;
            dummy=cur;
            cur=dummy->next;
        }return mark;
    }
};
```
## 25.k个翻转链表
递归
```
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        ListNode* count=head; int len=0;
        while(count&&len!=k){
            count=count->next;
            len++;
        }if(len<k) return head;
        ListNode* cur,* tmp, * begin;
        cur=head; begin=cur;
        for(int i=0; i<k-1; i++){
            tmp=cur->next;
            cur->next=tmp->next;
            tmp->next=begin;
            begin=tmp;
        }cur->next=reverseKGroup(cur->next, k);
        return begin;
    }
};
```
## 26.删除数组重复项
虽然是个easy题，但是我觉得这个双指针还是很优雅的
```
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if(nums.size()<2) return nums.size();
        int i=0;
        for(int j=1; j<nums.size(); j++){
            if(nums[i]!=nums[j]){
                i++;
                nums[i]=nums[j];
            }
        }return i+1;
    }
};
```
## 28.实现substr
也是个easy题，不过涉及到了KMP，借机会复习一下。

暴力：
```
class Solution {
public:
    int strStr(string haystack, string needle) {
        if(needle.size()==0) return 0;
        if(needle.size()>haystack.size()) return -1;
        for(int i=0; i<haystack.size()-needle.size()+1; i++){
            if(haystack.substr(i,needle.size())==needle)
                return i;
        }return -1;
    }
};
```
![text](http://ww1.sinaimg.cn/large/007ZpW3Dgy1ggstmde0rvj30d001y3yg.jpg)

![a](http://ww3.sinaimg.cn/large/006tNc79gw1fb0neee6mlj30dw0aldgf.jpg)

copy一个KMP算法：

https://leetcode-cn.com/problems/implement-strstr/solution/c-zhong-gui-zhong-ju-de-0msjie-fa-kmp-by-gary_co-2/
```
class Solution {
    vector<int> next;
    int n;
public:
    int strStr(string str, string pat) {
        n = pat.size();
        if (n == 0) return 0;
        getnext(pat);

        int i = 0, len = 0;
        while (i < str.size()) { //时间O(M)
            if (str[i] == pat[len]) { //字母相等，匹配成功，匹配长度+1
                ++i; ++len;
                if (len == n) return i - len;
            }
            else if (len == 0) ++i; //匹配失败，匹配长度为 0，无公共串
            else len = next[len - 1]; //匹配失败，看看公共串有没有前缀和后缀相等的部分，有的话，相等部分的后一个字母比较，没有的话证明当前字符串中没有与模式串前缀相等的部分
        }
        return -1;
    }

    void getnext(string& pat) { //时间O(N)
        next.resize(n);
        int len = 0, i = 1;
        while (i < n) {
            if (pat[i] == pat[len]) next[i++] = ++len;
            else if (len == 0) next[i++] = 0; //匹配失败，匹配长度为 0，无公共串
            else len = next[len - 1]; //匹配失败，看看公共串有没有前缀和后缀相等的部分，有的话，相等部分的后一个字母比较
        }
    }
};
```